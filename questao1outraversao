import numpy as np

def needleman_wunsch(seq1, seq2, match_score=2, mismatch_score=-2, gap_penalty=-3):
    """
    Realiza o alinhamento global de duas sequências usando o algoritmo de Needleman-Wunsch.

    Args:
        seq1 (str): A primeira sequência.
        seq2 (str): A segunda sequência.
        match_score (int): Pontuação para um match.
        mismatch_score (int): Pontuação para um mismatch.
        gap_penalty (int): Penalidade para um gap.

    Returns:
        tuple: A pontuação final do alinhamento, a primeira sequência alinhada,
               a segunda sequência alinhada e a linha de correspondência.
    """
    # Obter os comprimentos das sequências
    n = len(seq1)
    m = len(seq2)

    # 1. Criação da Matriz de Pontuação
    # Inicializa a matriz com zeros, com dimensões (m+1) x (n+1)
    score_matrix = np.zeros((m + 1, n + 1))

    # Inicializa a primeira linha e a primeira coluna com as penalidades de gap cumulativas
    for i in range(m + 1):
        score_matrix[i][0] = i * gap_penalty
    for j in range(n + 1):
        score_matrix[0][j] = j * gap_penalty

    # Preenche o restante da matriz
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # Calcula a pontuação para um match ou mismatch
            match = score_matrix[i - 1][j - 1] + (match_score if seq1[j - 1] == seq2[i - 1] else mismatch_score)
            # Calcula a pontuação para um gap na seq1 (movimento para cima)
            delete = score_matrix[i - 1][j] + gap_penalty
            # Calcula a pontuação para um gap na seq2 (movimento para a esquerda)
            insert = score_matrix[i][j - 1] + gap_penalty
            # A célula recebe o valor máximo entre as três opções
            score_matrix[i][j] = max(match, delete, insert)

    # 2. Traceback
    # Strings para armazenar as sequências alinhadas e a linha de correspondência
    align1, align2, correspondence = "", "", ""
    i, j = m, n # Começa do canto inferior direito da matriz

    while i > 0 or j > 0:
        current_score = score_matrix[i][j]
        diagonal_score = score_matrix[i-1][j-1] if i > 0 and j > 0 else float('-inf')
        up_score = score_matrix[i-1][j] if i > 0 else float('-inf')
        left_score = score_matrix[i][j-1] if j > 0 else float('-inf')

        # Verifica se o caractere atual é um match ou mismatch
        char_score = match_score if seq1[j-1] == seq2[i-1] else mismatch_score

        # Prioridade no traceback: Diagonal > Cima > Esquerda
        if i > 0 and j > 0 and current_score == diagonal_score + char_score:
            align1 = seq1[j-1] + align1
            align2 = seq2[i-1] + align2
            correspondence = ("|" if seq1[j-1] == seq2[i-1] else " ") + correspondence
            i -= 1
            j -= 1
        elif i > 0 and current_score == up_score + gap_penalty:
            align1 = "-" + align1
            align2 = seq2[i-1] + align2
            correspondence = " " + correspondence
            i -= 1
        else: # O movimento deve ter vindo da esquerda
            align1 = seq1[j-1] + align1
            align2 = "-" + align2
            correspondence = " " + correspondence
            j -= 1

    final_score = score_matrix[m][n]
    return int(final_score), align1, align2, correspondence

def calculate_identity(aligned_seq1, aligned_seq2):
    """
    Calcula a porcentagem de identidade entre duas sequências já alinhadas.

    Args:
        aligned_seq1 (str): A primeira sequência alinhada.
        aligned_seq2 (str): A segunda sequência alinhada.

    Returns:
        float: A porcentagem de identidade.
    """
    identities = 0
    alignment_length = len(aligned_seq1)

    if alignment_length == 0:
        return 0.0

    for i in range(alignment_length):
        if aligned_seq1[i] == aligned_seq2[i]:
            identities += 1

    return (identities / alignment_length) * 100

# --- Dados de Entrada ---
seq_homo_sapiens = "VLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHGKKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAHLPAEFTPAVHASLDKFLASVSTVLTSKY"
seq_equus_caballus = "VLSAADKTNVKAAWSKVGGHAGEYGAEALERMFLGFPTTKTYFPHFDLSHGSAQVKAHGKKVGDALTLAVGHLDDLPGALSNLSDLHAHKLRVDPVNFKLLSHCLLSTLAVHLPNDFTPAVHASLDKFLSSVSTVLTSKYR"
seq_odocoileus_virginianus = "VLSAANKSNVKAAWGKVGGNAPAYGAQALQRMFLSFPTTKTYFPHFDLSHGSAQQKAHGQKVANALTKAQGHLNDLPGTLSNLSNLHAHKLRVNPVNFKLLSHSLLVTLASHLPTNFTPAVHANLNKFLANDSTVLTSKYR"
seq_bos_taurus = "VLSAADKGNVKAAWGKVGGHAAEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHGAKVAAALTKAVEHLDDLPGALSELSDLHAHKLRVDPVNFKLLSHSLLVTLASHLPSDFTPAVHASLDKFLANVSTVLTSKYR"

sequences = {
    "Equus caballus": seq_equus_caballus,
    "Odocoileus virginianus": seq_odocoileus_virginianus,
    "Bos taurus": seq_bos_taurus
}

# --- Execução e Resultados ---
results = {}

for name, seq in sequences.items():
    score, align1, align2, correspondence = needleman_wunsch(seq_homo_sapiens, seq)
    identity = calculate_identity(align1, align2)
    results[name] = {
        "score": score,
        "identity": identity,
        "alignment": (align1, correspondence, align2)
    }

def main():
    for name, result in results.items():
        print(f"--- {name} ---")
        print(f"Pontuação: {result['score']}")
        print(f"Identidade: {result['identity']:.2f}%")
        print("Alinhamento:")
        print(result['alignment'][0])
        print(result['alignment'][1])
        print(result['alignment'][2])
        print("\n")

if __name__ == "__main__":
    main()
